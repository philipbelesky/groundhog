namespace Groundhog
{
    using System;
    using System.Collections.Generic;
    using System.Drawing;
    using Grasshopper.Kernel;
    using Groundhog.Properties;
    using Rhino.Geometry;

    public class FieldVisualisationGridComponent : GroundHogComponent
    {
        public FieldVisualisationGridComponent()
            : base("Field Visualisation (Grid)", "Field Grid",
                "Translate a field into a grid based visualisation. Outputs a number constrained by a range which can be used to then make a color or shape.",
                "Groundhog", "Mapping")
        {
        }

        public override Guid ComponentGuid => new Guid("34ab1ff1-fee6-4a7c-a8cb-1d074b7ff4c3");

        protected override Bitmap Icon => Resources.icon_field_grid_vis;

        protected override void RegisterInputParams(GH_InputParamManager pManager)
        {
            pManager.AddSurfaceParameter(
                "Field", "F", "Field generated by a Field Component", GH_ParamAccess.item);
            pManager.AddCurveParameter(
                "Bounds", "B", "Curve boundary to constraint the visualisation to a certain area", GH_ParamAccess.item);
            pManager[1].Optional = true;
            pManager.AddNumberParameter(
                "Domain Start", "DS", "Starting value representing the 'bottom' value", GH_ParamAccess.item, 0.0);
            pManager[2].Optional = true;
            pManager.AddNumberParameter(
                "Domain End", "DE", "Ending value representing the 'top' value", GH_ParamAccess.item, 1.0);
            pManager[3].Optional = true;
        }

        protected override void RegisterOutputParams(GH_OutputParamManager pManager)
        {
            pManager.AddPointParameter("Points", "P", "Grid Points", GH_ParamAccess.list);
            pManager.AddNumberParameter("Parameters", "P", "Grid Parameters", GH_ParamAccess.list);
        }

        protected override void GroundHogSolveInstance(IGH_DataAccess DA)
        {
            // Create holder variables for input parameters
            Surface GRID_RAW_FIELD = null;
            Curve GRID_BOUNDARY = null;
            var P_START = 0.0;
            var P_END = 1.0;

            if (!DA.GetData(0, ref GRID_RAW_FIELD)) return;
            if (!DA.GetData(1, ref GRID_BOUNDARY)) return;
            if (!DA.GetData(2, ref P_START)) return;
            if (!DA.GetData(3, ref P_END)) return;

            if (P_START == P_END)
                this.AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Parameter start and end numbers must be different");
            // Validate boundary curve is planar
            if (GRID_BOUNDARY != null && !GRID_BOUNDARY.IsPlanar())
                this.AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Boundary curve is not planar");
            if (GRID_BOUNDARY != null && !GRID_BOUNDARY.IsClosed)
                this.AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Boundary curve is not closed");

            var gridField = GRID_RAW_FIELD.ToNurbsSurface();
            if (GRID_RAW_FIELD == null)
                AddRuntimeMessage(
                    GH_RuntimeMessageLevel.Error, "Grid field is null or not able to be converted to a NURBS surface");

            var inBoundsPoints = new List<Point3d>();
            var surfaceCP = gridField.Points;
            double? lowestZ = null; // Track lowest point for range normalisation purposes
            double? highestZ = null; // Track lowest point for range normalisation purposes
            var uCount = surfaceCP.CountU;
            var vCount = surfaceCP.CountV;

            // Get Euclidean point coordinates and remove points out of bounds
            for (var u = 0; u < uCount; u = u + 1)
            for (var v = 0; v < vCount; v = v + 1)
            {
                var point = surfaceCP.GetControlPoint(u, v).Location;
                if (!lowestZ.HasValue || point.Z < lowestZ) lowestZ = point.Z;
                if (!highestZ.HasValue || point.Z > highestZ) highestZ = point.Z;

                if (GRID_BOUNDARY != null)
                {
                    var pointContainment = GRID_BOUNDARY.Contains(point, Plane.WorldXY, this.docUnitTolerance);
                    if (pointContainment.ToString() == "Inside") inBoundsPoints.Add(point);
                }
                else
                {
                    inBoundsPoints.Add(point);
                }
            }

            // Check before force-unwrapping with .Value() below
            if (highestZ == null)
                this.AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Upper bound null; this shouldn't happen");
            if (lowestZ == null)
                this.AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Upper bound null; this shouldn't happen");

            var inBoundsParameters = new List<double>();
            for (var i = 0; i < inBoundsPoints.Count; i = i + 1)
            {
                var z = inBoundsPoints[i].Z;
                var remappedZ = this.Remap(z, lowestZ.Value, highestZ.Value, P_START, P_END);
                inBoundsParameters.Add(remappedZ);
            }

            // Assign variables to output parameters
            DA.SetDataList(0, inBoundsPoints);
            DA.SetDataList(1, inBoundsParameters);
        }

        private double Remap(double value, double fromLow, double fromHigh, double toLow, double toHigh)
        {
            // Should really make this a shared method; I use it all over the show
            return ((value - fromLow) / (fromHigh - fromLow)) * ((toHigh - toLow) + toLow);
        }
    }
}